# Лабораторная работа 1 (TreeDataStructures)

## Общее описание
Целью работы является реализация иерархии generic структур данных на основе деревьев поиска. Все реализации должны соответствовать принципам SOLID и использовать паттерны проектирования.

+ Все задания реализуются на языке программирования C#14 . 
+ Реализованные в заданиях приложения не должны завершаться аварийно; **все** возникающие исключительные ситуации должны быть перехвачены и обработаны.
+ Во всех заданиях запрещено пользоваться функциями, позволяющими завершить выполнение приложения из произвольной точки выполнения.
+ Во всех заданиях при реализации необходимо разделять контексты работы с данными (поиск,сортировка, добавление/удаление, модификация и т. п.) и отправка данных в поток вывода /выгрузка данных из потока ввода.
+ Во всех заданиях все вводимые (с консоли, файла, командной строки) пользователем данные должны (если не сказано обратное) быть подвергнуты валидации в соответствии с типом валидируемых данных.
+ Во всех заданиях необходимо контролировать ситуации с невозможностью [пере]выделения памяти; во всех заданиях необходимо корректно освобождать всю выделенную динамическую память.
+ Все ошибки, связанные с операциями открытия файла, должны быть обработаны; все открытые файлы должны быть закрыты.
+ Реализованные компоненты должны зависеть от абстракций, а не от конкретных реализаций абстракций. 
+ Для задач, для которых написаны тесты, находящиется в `TreeDataStructures.Tests`, требуется демонстрация прохождения всех описанных тестов для реализованных компонентов. Модификация кода тестов запрещена

### 1. Базовое Дерево Двоичного Поиска (BST)

Реализуйте базовую инфраструктуру для работы с ассоциативными контейнерами на основе деревьев. Задача разделена на проектирование абстрактного каркаса и создание стандартного (несбалансированного) BST.

#### 1.1. Абстрактный класс `BinarySearchTreeBase<TKey, TValue, TNode>`
Этот класс реализует общую логику для всех типов деревьев поиска (AVL, RB, Splay и Treap), используя паттерн **«Шаблонный метод»**.

**Путь в репозитории:** `/TreeDataStructures/Core/BinarySearchTreeBase`

Реализуйте абстрактный класс `BinarySearchTreeBase<TKey, TValue, TNode>`, соответствующий следующим требованиям:

Операции CRUD (вставка, поиск, удаление) должны быть реализованы как шаблонные методы. Основной алгоритм BST описывается в базовом классе, но в ключевых точках вызываются вспомогательные методы для балансировки (hooks), которые переопределяются в типах-наследниках (AVL, RB, Splay, Treap).

#### Итераторы (Traverse)
Реализуйте поддержку *6 типов итераторов**, представляющих собой декартово произведение следующих множеств свойств:
1.  **Вид обхода:** Префиксный (Pre-order), Инфиксный (In-order), Постфиксный (Post-order).
2.  **Направление:** Прямой, Обратный (Reverse).

Каждый итератор при обходе должен предоставлять доступ к:
- Ключу (`TKey`)
- Значению (`TValue`)
- Высоте данного поддерева

Для реализации итераторов используйте внутренний класс `TreeIterator`, использование ключевых слов `yield return` при выполнении задания недопустимо.

#### Операции поворотов
Реализуйте в базовом классе методы для трансформации дерева:
- Малый левый/правый повороты.
- Двойной левый/правый повороты.
- Большой левый/правый повороты.

#### 1.2 Класс `BinarySearchTree<TKey, TValue>`
Напишите реализацию класса `BinarySearchTree<TKey, TValue>`, который наследуется от `BinarySearchTreeBase<TKey, TValue, BstNode<TKey, TValue>>`, выполненного в п. 1.1, представляющую конкретную реализацию дерева двоичного поиска

**Путь в репозитории:** `/TreeDataStructures/Implementations/BST/BinarySearchTree`

---


### 2. Декартово дерево (Treap)
**Путь в репозитории:** `/TreeDataStructures/Implementations/Treap`

На основе класса BST, реализованного в задании 1, реализуйте родовой класс Декартова дерева. Для реализации пронаследуйте тип узла дерева двоичного поиска с добавлением необходимой
информации переопределите/доопределите функционал шаблонных методов для обеспечения выполнения балансировки дерева после выполнения основного алгоритма.

---

### 3. АВЛ-дерево
**Путь в репозитории:** `/TreeDataStructures/Implementations/AVL`

На основе класса BST, реализованного в задании 1, реализуйте родовой класс АВЛ-дерева. Для реализации пронаследуйте тип узла дерева двоичного поиска с добавлением необходимой
информации переопределите/доопределите функционал шаблонных методов для обеспечения выполнения балансировки дерева после выполнения основного алгоритма.

---

### 4. Красно-чёрное дерево
**Путь в репозитории:**  `/TreeDataStructures/Implementations/RedBlackTree`

На основе класса BST, реализованного в задании 1, реализуйте родовой класс крачно-чёрного дерева. Для реализации пронаследуйте тип узла дерева двоичного поиска с добавлением необходимой
информации переопределите/доопределите функционал шаблонных методов для обеспечения выполнения балансировки дерева после выполнения основного алгоритма.

---

### 5. Косое дерево (Splay Tree)
**Путь в репозитории:** `/TreeDataStructures/Implementations/Splay`

На основе класса BST, реализованного в задании 1, реализуйте родовой класс splay-дерева. Для реализации пронаследуйте тип узла дерева двоичного поиска с добавлением необходимой
информации переопределите/доопределите функционал шаблонных методов для обеспечения выполнения балансировки дерева после выполнения основного алгоритма.


---
